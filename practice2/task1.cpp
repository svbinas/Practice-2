#include <iostream>                         // Я подключаю iostream, чтобы выводить результаты в консоль
#include <vector>                           // Я подключаю vector, чтобы хранить массивы удобно
#include <random>                           // Я подключаю random, чтобы нормально генерировать случайные числа
#include <chrono>                           // Я подключаю chrono, чтобы измерять время выполнения
#include <algorithm>                        // Я подключаю algorithm, чтобы проверить, отсортирован ли массив (is_sorted)
#include <omp.h>                            // Я подключаю OpenMP, чтобы использовать параллельные директивы

using namespace std;                        // Я использую std без std::, чтобы код был короче

// ---------------------------
// Я делаю функцию генерации массива случайных чисел
// ---------------------------
vector<int> make_random_array(int n) {      // Я объявляю функцию, которая создаёт массив размера n
    vector<int> a(n);                       // Я создаю vector из n элементов
    mt19937 rng((unsigned)time(nullptr));   // Я создаю генератор случайных чисел и инициализирую временем
    uniform_int_distribution<int> dist(1, 1000000); // Я задаю диапазон значений, чтобы числа были разнообразные
    for (int i = 0; i < n; i++) {           // Я прохожусь по всем индексам
        a[i] = dist(rng);                   // Я записываю случайное число в a[i]
    }                                       // Я закрываю цикл
    return a;                               // Я возвращаю готовый массив
}                                           // Я закрываю функцию

// ---------------------------
// 1) ПОСЛЕДОВАТЕЛЬНЫЕ СОРТИРОВКИ
// ---------------------------
void bubble_seq(vector<int>& a) {           // Я объявляю последовательную сортировку пузырьком
    int n = (int)a.size();                  // Я сохраняю размер массива
    for (int i = 0; i < n - 1; i++) {       // Я делаю n-1 проходов
        for (int j = 0; j < n - 1 - i; j++) { // Я сравниваю соседние элементы до конца несортированной части
            if (a[j] > a[j + 1]) {          // Я проверяю, нарушен ли порядок
                int tmp = a[j];             // Я сохраняю a[j] во временную переменную
                a[j] = a[j + 1];            // Я ставлю меньший элемент на место a[j]
                a[j + 1] = tmp;             // Я возвращаю tmp на позицию j+1
            }                               // Я закрываю if
        }                                   // Я закрываю внутренний цикл
    }                                       // Я закрываю внешний цикл
}                                           // Я закрываю функцию

void selection_seq(vector<int>& a) {        // Я объявляю последовательную сортировку выбором
    int n = (int)a.size();                  // Я беру размер массива
    for (int i = 0; i < n - 1; i++) {       // Я ставлю минимум на позицию i
        int min_idx = i;                    // Я считаю, что минимум пока в i
        for (int j = i + 1; j < n; j++) {   // Я ищу минимум справа
            if (a[j] < a[min_idx]) {        // Я сравниваю с текущим минимумом
                min_idx = j;                // Я обновляю индекс минимума
            }                               // Я закрываю if
        }                                   // Я закрываю поиск минимума
        int tmp = a[i];                     // Я сохраняю a[i]
        a[i] = a[min_idx];                  // Я ставлю минимум на позицию i
        a[min_idx] = tmp;                   // Я возвращаю старое значение на место минимума
    }                                       // Я закрываю внешний цикл
}                                           // Я закрываю функцию

void insertion_seq(vector<int>& a) {        // Я объявляю последовательную сортировку вставкой
    int n = (int)a.size();                  // Я беру размер массива
    for (int i = 1; i < n; i++) {           // Я начинаю со второго элемента
        int key = a[i];                     // Я сохраняю текущий элемент, который нужно вставить
        int j = i - 1;                      // Я начинаю сравнивать слева от i
        while (j >= 0 && a[j] > key) {      // Я двигаю элементы вправо, пока они больше key
            a[j + 1] = a[j];                // Я сдвигаю элемент вправо
            j--;                            // Я иду дальше влево
        }                                   // Я закрываю while
        a[j + 1] = key;                     // Я вставляю key в правильное место
    }                                       // Я закрываю внешний цикл
}                                           // Я закрываю функцию

// ---------------------------
// 2) ПАРАЛЛЕЛЬНЫЕ ВЕРСИИ (OpenMP)
// ---------------------------

// Параллельный "пузырёк" (odd-even transposition sort) — корректный вариант для OpenMP
void bubble_omp_oddeven(vector<int>& a) {   // Я объявляю параллельный вариант пузырька через odd-even
    int n = (int)a.size();                  // Я беру размер массива
    for (int phase = 0; phase < n; phase++) { // Я делаю n фаз, этого достаточно, чтобы отсортировать
        int start = phase % 2;              // Я выбираю: чётная фаза (0) или нечётная (1)
        #pragma omp parallel for            // Я распараллеливаю сравнение независимых пар
        for (int j = start; j < n - 1; j += 2) { // Я беру пары (0,1)(2,3)... или (1,2)(3,4)...
            if (a[j] > a[j + 1]) {          // Я проверяю порядок в паре
                int tmp = a[j];             // Я сохраняю a[j]
                a[j] = a[j + 1];            // Я меняю местами элементы
                a[j + 1] = tmp;             // Я завершаю swap
            }                               // Я закрываю if
        }                                   // Я закрываю параллельный for
    }                                       // Я закрываю цикл фаз
}                                           // Я закрываю функцию

// Сортировка выбором: параллелизирую поиск минимума на каждом шаге (корректно)
void selection_omp(vector<int>& a) {        // Я объявляю параллельную сортировку выбором
    int n = (int)a.size();                  // Я беру размер массива
    for (int i = 0; i < n - 1; i++) {       // Я двигаю границу отсортированной части
        int min_val = a[i];                 // Я храню минимальное значение на этом шаге
        int min_idx = i;                    // Я храню индекс минимума

        #pragma omp parallel                // Я создаю параллельную область
        {                                   // Я открываю блок
            int local_min_val = min_val;    // Я создаю локальный минимум для потока
            int local_min_idx = min_idx;    // Я создаю локальный индекс минимума

            #pragma omp for nowait          // Я распределяю поиск минимума по потокам
            for (int j = i + 1; j < n; j++) { // Я ищу минимум справа от i
                if (a[j] < local_min_val) { // Я сравниваю с локальным минимумом
                    local_min_val = a[j];   // Я обновляю локальный минимум
                    local_min_idx = j;      // Я обновляю локальный индекс
                }                           // Я закрываю if
            }                               // Я закрываю for

            #pragma omp critical            // Я объединяю локальные результаты потоков безопасно
            {                               // Я открываю critical секцию
                if (local_min_val < min_val) { // Я сравниваю локальный минимум с глобальным
                    min_val = local_min_val;    // Я обновляю глобальный минимум
                    min_idx = local_min_idx;    // Я обновляю глобальный индекс
                }                           // Я закрываю if
            }                               // Я закрываю critical секцию
        }                                   // Я закрываю parallel область

        int tmp = a[i];                     // Я сохраняю a[i] для обмена
        a[i] = a[min_idx];                  // Я ставлю найденный минимум на позицию i
        a[min_idx] = tmp;                   // Я возвращаю tmp на место минимума
    }                                       // Я закрываю внешний цикл
}                                           // Я закрываю функцию

// Вставка: корректная параллелизация через блоки + локальная insertion sort + слияние
// (это “реальная” параллельная стратегия для вставки/малых сортировок)
void insertion_omp_blockmerge(vector<int>& a) {  // Я объявляю параллельную вставку через блоки
    int n = (int)a.size();                       // Я беру размер массива
    int threads = omp_get_max_threads();         // Я беру количество доступных потоков
    int block = (n + threads - 1) / threads;     // Я делю массив на блоки по числу потоков

    // 1) Сначала каждый поток сортирует свой блок обычной insertion sort
    #pragma omp parallel for                     // Я распараллеливаю обработку блоков
    for (int t = 0; t < threads; t++) {          // Я перебираю блоки по номеру потока
        int L = t * block;                       // Я вычисляю начало блока
        int R = min(L + block, n);               // Я вычисляю конец блока (не выхожу за n)

        for (int i = L + 1; i < R; i++) {        // Я делаю insertion sort внутри блока
            int key = a[i];                      // Я беру текущий элемент
            int j = i - 1;                       // Я иду влево
            while (j >= L && a[j] > key) {       // Я сдвигаю элементы внутри блока
                a[j + 1] = a[j];                 // Я двигаю вправо
                j--;                             // Я уменьшаю j
            }                                    // Я закрываю while
            a[j + 1] = key;                      // Я вставляю key на место
        }                                        // Я закрываю сортировку блока
    }                                            // Я закрываю parallel for

    // 2) Потом я поэтапно сливаю отсортированные блоки (как merge sort)
    vector<int> tmp(n);                          // Я создаю временный массив для слияния
    int run = block;                             // Я начинаю с размера блока

    while (run < n) {                            // Я пока размер отсортированных “ранов” меньше массива
        #pragma omp parallel for                 // Я распараллеливаю независимые слияния
        for (int start = 0; start < n; start += 2 * run) { // Я беру пары ран для слияния
            int mid = min(start + run, n);       // Я нахожу середину
            int end = min(start + 2 * run, n);   // Я нахожу конец

            int i = start;                       // Я иду по левой части
            int j = mid;                         // Я иду по правой части
            int k = start;                       // Я пишу в tmp начиная со start

            while (i < mid && j < end) {         // Я сливаю пока обе части не закончились
                if (a[i] <= a[j]) tmp[k++] = a[i++]; // Я беру меньший элемент
                else              tmp[k++] = a[j++]; // Или беру из правой части
            }                                     // Я закрываю while
            while (i < mid) tmp[k++] = a[i++];    // Я докидываю остаток левой части
            while (j < end) tmp[k++] = a[j++];    // Я докидываю остаток правой части
        }                                         // Я закрываю parallel for слияния

        a.swap(tmp);                               // Я меняю местами a и tmp, чтобы новый результат стал основным массивом
        run *= 2;                                  // Я увеличиваю размер ран в 2 раза
    }                                              // Я закрываю while
}                                                  // Я закрываю функцию

// ---------------------------
// Я делаю универсальный замер времени для любой функции сортировки
// ---------------------------
template <typename Func>                            // Я делаю шаблон, чтобы передавать любую функцию сортировки
long long measure_us(Func f, vector<int> a) {       // Я принимаю функцию и копию массива (чтобы не портить оригинал)
    auto t1 = chrono::high_resolution_clock::now(); // Я фиксирую старт времени
    f(a);                                           // Я запускаю сортировку
    auto t2 = chrono::high_resolution_clock::now(); // Я фиксирую конец времени
    if (!is_sorted(a.begin(), a.end())) {           // Я проверяю, что массив действительно отсортирован
        cout << "ERROR: array is not sorted!\n";    // Если нет — я сообщаю об ошибке
    }                                               // Я закрываю if
    return chrono::duration_cast<chrono::microseconds>(t2 - t1).count(); // Я возвращаю время в микросекундах
}                                                   // Я закрываю функцию

int main() {                                        // Я начинаю main
    vector<int> sizes = {1000, 10000, 100000};      // Я задаю размеры массивов для теста

    cout << "OpenMP threads: " << omp_get_max_threads() << "\n\n"; // Я печатаю сколько потоков доступно

    for (int n : sizes) {                           // Я прохожусь по каждому размеру
        vector<int> base = make_random_array(n);    // Я создаю базовый случайный массив

        cout << "N = " << n << "\n";                // Я вывожу текущий размер массива

        // ---------- Bubble ----------
        long long b_seq = measure_us(bubble_seq, base);                 // Я измеряю последовательный пузырёк
        long long b_par = measure_us(bubble_omp_oddeven, base);         // Я измеряю параллельный пузырёк (odd-even)

        cout << "Bubble seq: " << b_seq << " us\n";  // Я печатаю время seq пузырька
        cout << "Bubble omp: " << b_par << " us\n";  // Я печатаю время omp пузырька

        // ---------- Selection ----------
        long long s_seq = measure_us(selection_seq, base);              // Я измеряю последовательный выбор
        long long s_par = measure_us(selection_omp, base);              // Я измеряю параллельный выбор (параллельный поиск минимума)

        cout << "Select seq: " << s_seq << " us\n";  // Я печатаю время seq выбора
        cout << "Select omp: " << s_par << " us\n";  // Я печатаю время omp выбора

        // ---------- Insertion ----------
        long long i_seq = measure_us(insertion_seq, base);              // Я измеряю последовательную вставку
        long long i_par = measure_us(insertion_omp_blockmerge, base);   // Я измеряю параллельную вставку (блоки + слияние)

        cout << "Insert seq: " << i_seq << " us\n";  // Я печатаю время seq вставки
        cout << "Insert omp: " << i_par << " us\n";  // Я печатаю время omp вставки

        cout << "-----------------------------\n";   // Я вывожу разделитель
    }                                                // Я закрываю цикл по размерам

    return 0;                                        // Я завершаю программу
}                                                    // Я закрываю main
